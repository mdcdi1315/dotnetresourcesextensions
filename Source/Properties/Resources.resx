<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="InvalidResXBasePathOperation" xml:space="preserve">
    <value>Property can be changed only before the enumeration.</value>
  </data>
  <data name="InvalidResXFile" xml:space="preserve">
    <value>ResX file {0} cannot be parsed.</value>
  </data>
  <data name="InvalidResXFileReaderWriterTypes" xml:space="preserve">
    <value>ResX input is not valid. Cannot find valid "resheader" tags for the ResX reader and writer type names.</value>
  </data>
  <data name="InvalidResXNoType" xml:space="preserve">
    <value>Could not find a type for a name.  The type name was '{0}'.</value>
  </data>
  <data name="InvalidResXResourceNoName" xml:space="preserve">
    <value>Cannot find a name for the resource with the value '{0}'.</value>
  </data>
  <data name="ResXResourceWriterSaved" xml:space="preserve">
    <value>Resource writer has been saved.  You may not edit it.</value>
  </data>
  <data name="TypeLoadException" xml:space="preserve">
    <value>Type {0} in the data at line {1}, position {2} cannot be located.</value>
  </data>
  <data name="NotSupported" xml:space="preserve">
    <value>The type {0} on line {1}, position {2} threw the following exception while being converted: {3}</value>
  </data>
  <data name="TypeLoadExceptionShort" xml:space="preserve">
    <value>Type {0} cannot be located.</value>
  </data>
  <data name="SerializationException" xml:space="preserve">
    <value>Type {0} could not be read from the data in line {1}, position {2}.  The type's internal structure may have changed.  Either implement ISerializable on the type or provide a type converter that can provide a more reliable conversion format, such as text or an array of bytes.  The conversion exception was: {3}</value>
  </data>
  <data name="InvocationException" xml:space="preserve">
    <value>Type {0} in the data at line {1}, position {2}, cannot be loaded because it threw the following exception during construction: {3}</value>
  </data>
  <data name="NotSerializableType" xml:space="preserve">
    <value>Item named '{0}' of type '{1}' cannot be added to the resource file because it is not serializable.</value>
  </data>
  <data name="DotNetResourcesException_Message" xml:space="preserve">
    <value>{0}
Resource Name: {1}</value>
  </data>
  <data name="ResourceNotFoundException_Ctor" xml:space="preserve">
    <value>The resource '{0}' was not found.</value>
  </data>
  <data name="ResourceParsersException_Message" xml:space="preserve">
    <value>{0}
This exception is related with the category '{1}'. 
Original Parser Error: {2}</value>
  </data>
  <data name="ResourceTypeMismatchException_Ctor" xml:space="preserve">
    <value>The resource '{0}' is not a '{1}' - it is a '{2}'.</value>
  </data>
  <data name="ResourceTypeMismatchException_Message" xml:space="preserve">
    <value>{0}
Expected Resource Type: {1}
Recieved Resource Type: {2}
Resource Name: {3}</value>
  </data>
  <data name="Argument_StreamNotWritable" xml:space="preserve">
	<value>Stream was not writable.</value>
  </data>
  <data name="InvalidOperation_ResourceNotString_Type" xml:space="preserve">
	<value>Resource was of type '{0}' instead of String - call GetObject instead.</value>
  </data>
  <data name="BadImageFormat_ResourcesDataInvalidOffset" xml:space="preserve">
	<value>Corrupt .resources file. Invalid offset '{0}' into data section.</value>
  </data>
  <data name="NotSupported_WrongResourceReader_Type" xml:space="preserve">
	<value>This .resources file should not be read with this reader. The resource reader type is "{0}".</value>
  </data>
  <data name="InvalidOperation_EnumNotStarted" xml:space="preserve">
	<value>Enumeration has not started. Call MoveNext.</value>
  </data>
  <data name="Argument_StreamNotReadable" xml:space="preserve">
	<value>Stream was not readable</value>
  </data>
  <data name="ObjectDisposed_ResourceSet" xml:space="preserve">
	<value>Cannot access a closed resource set.</value>
  </data>
  <data name="TypeLoadException_CannotLoadConverter" xml:space="preserve"><value>Could not load a converter for type {0}.</value></data>
  <data name="NotSupported_UnseekableStream" xml:space="preserve"><value>Stream does not support seeking.</value></data>
  <data name="InvalidOperation_ResourceWriterSaved" xml:space="preserve"><value>The resource writer has already been closed and cannot be edited.</value></data>
  <data name="BadImageFormat_ResType_SerBlobMismatch" xml:space="preserve"><value>The type serialized in the .resources file was not the same type that the .resources file said it contained. Expected '{0}' but read '{1}'.</value></data>
  <data name="BadImageFormat_ResourcesNameInvalidOffset" xml:space="preserve"><value>Corrupt .resources file. Invalid offset '{0}' into name section.</value></data>
  <data name="BadImageFormat_ResourcesHeaderCorrupted" xml:space="preserve"><value>Corrupt .resources file. Unable to read resources from this file because of invalid header information. Try regenerating the .resources file.</value></data>
  <data name="ArgumentOutOfRange_StreamLength" xml:space="preserve"><value>Stream length must be non-negative and less than 2^31 - 1 - origin.</value></data>
  <data name="Arg_ResourceFileUnsupportedVersion" xml:space="preserve"><value>The ResourceReader class does not know how to read this version of .resources files. Expected version: {0}  This file: {1}</value></data>
  <data name="BadImageFormat_TypeMismatch" xml:space="preserve"><value>Corrupt .resources file.  The specified type doesn't match the available data in the stream.</value></data>
  <data name="ResourceReaderIsClosed" xml:space="preserve"><value>ResourceReader is closed.</value></data>
  <data name="NotSupported_ResourceObjectSerialization" xml:space="preserve"><value>Cannot read resources that depend on serialization.</value></data>
  <data name="BadImageFormat_NegativeStringLength" xml:space="preserve"><value>Corrupt .resources file. String length must be non-negative.</value></data>
  <data name="Resources_StreamNotValid" xml:space="preserve"><value>Stream is not a valid resource file.</value></data>
  <data name="ResourceManager_ReflectionNotAllowed" xml:space="preserve"><value>Use of ResourceManager for custom types is disabled. Set the MSBuild Property CustomResourceTypesSupport to true in order to enable it.</value></data>
  <data name="Format_Bad7BitInt32" xml:space="preserve"><value>Too many bytes in what should have been a 7 bit encoded Int32.</value></data>
  <data name="BadImageFormat_ResourceNameCorrupted_NameIndex" xml:space="preserve"><value>Corrupt .resources file. The resource name for name index {0} extends past the end of the stream.</value></data>
  <data name="BadImageFormat_ResourcesIndexTooLong" xml:space="preserve"><value>Corrupt .resources file. String for name index '{0}' extends past the end of the file.</value></data>
  <data name="BadImageFormat_ResourceNameCorrupted" xml:space="preserve"><value>Corrupt .resources file. A resource name extends past the end of the stream.</value></data>
  <data name="BadImageFormat_InvalidType" xml:space="preserve"><value>Corrupt .resources file.  The specified type doesn't exist.</value></data>
  <data name="BadImageFormat_ResourcesNameTooLong" xml:space="preserve"><value>Corrupt .resources file. Resource name extends past the end of the file.</value></data>
  <data name="BadImageFormat_ResourceDataLengthInvalid" xml:space="preserve"><value>Corrupt .resources file.  The specified data length '{0}' is not a valid position in the stream.</value></data>
  <data name="NotSupported_BinarySerializedResources" xml:space="preserve"><value>This platform does not support binary serialized resources.</value></data>
  <data name="InvalidOperation_EnumEnded" xml:space="preserve"><value>Enumeration already finished.</value></data>
</root>